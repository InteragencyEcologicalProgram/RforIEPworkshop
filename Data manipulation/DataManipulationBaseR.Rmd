---
title: ''
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Style Guide

Herein, I present some quick points about my style guide. This is by no means the best approach but one that has worked for me and one I've developed over the years.

PascalCase: function names; dataframes; field headings; file names  
camelCase: function parameters  
lower_case (with underscore): variables  

use `<-` instead of `=` for variable assignment  
most everytime function call, hard return after left parentheses  
each line keep to max 80 characters  

Below is an example creating a function, and then calling that function. Note how in the call each function parameter is on its own line. This allows for easily commenting a parameter to try another argument (see `speciesName`).

```
# create function
LengthFrequency <- function(data, speciesName, forkLength) {
  # do something here
}
# end LengthFrequency

len_freq <- LengthFrequency(
  data = Sturgeon,
  speciesName = "white",
  # speciesName = "green",
  forkLength = TRUE
)
```
# Functional Programming

`R` is a functional programming language. As such, it has certain characteristics that can work to one's advantage.

- everything is a function call
- arguments can be other functions
- functions can return functions

# Function Call

Here, we use `iris`, the built-in dataframe in `datasets` package. Below demonstrates the 'everything is a function call' aspect. Commented sections display the much more common use.

```{r func-call}

`+`(9, 8)                      # 9 + 8

`<-`(x, 1:10)                  # x <- 1:10 or x = 1:10
print(x)

`==`(9, 8)                     # 9 == 8

`[`(iris, 1, 2)                # iris[1, 2]
`[[`(iris, 1, 2)               # iris[[1, 2]]

`[[`(iris, 1, "Sepal.Width")   # iris[[1, "Sepal.Width"]]

# Not run --------------------------------------------------
# `[`(iris, 5)                 # iris[5]
# `[`(iris, , 5, drop = TRUE)  # iris[, 5, drop = TRUE]
# `[[`(iris, 5)                # iris[[5]]

```

To know the what-why-when's of the  `<l|v|m>apply()` family of `package:base` functions, it helps to understand --- at least conceptually --- about a `for` loop. For some items in variable `x`, do something.

# `for` Loop

```
for (items in variable) {
  # do something
}
```

...an example

```{r for-loop}
for (i in 1:5) {
  print(i)
}
```

# `<_>apply` Family Functions

Here in `lapply` the argument to `FUN` is that 'do something' in the `for` loop. The function passed to `FUN`, will act on every item in the `list or vector`. 

```
lapply(list or vector, FUN = function(x) # do something)
```
# `lapply` Inner Workings

```{r lapply-show}

lapply

```

# `lapply` First Example

Here we supply the vetor 1-->5. We wish to add 5 to each number in that vector.

```{r fun-lapply}

lapply(1:5, FUN = `+`, 5)

```

# Vectorized

But because R is vectorized, we can simply write below. The results remain neatly in a vector.

```{r vectorized}
1:5 + 5
```

# `lapply` On List

But what if instead of a vector, we had a **list** of vectors? (an uneven list in this case)

```{r list-create}

X <- list(
  Item1 = 1:5,
  Item2 = 6:10,
  Item3 = 11:20
)

X

```

because `X` is a list, vectorization concept doesn't work...

```{r list-add5, eval=FALSE}

X + 5
# Error in X + 5 : non-numeric argument to binary operator

```

so, here's where `lapply` is useful. (Adding `5` may not be of particular importance, but what about sqaring each value?)

```{r list-lapply}

lapply(X, FUN = `+`, 5)
lapply(X, FUN = `^`, 2)

```

We can certainly supply a built-in function to `FUN`. Sometimes it is useful to get count for each item in list.

```{r length-X}

lapply(X, FUN = length)

```

# `vapply` Inner Workings

`vapply` is quite similar to `lapply` but includes some extra (and convenient) parameters.

```{r vapply-show}

vapply

```

# `vapply` Example

We can tell `vapply` the expected output of `FUN`. We know `base::length()` returns a single numeric value, so we can supply just that to `FUN.VALUE`. *Note*: the `L` maintains 1 as an integer value, not a double.)

```{r vapply-example}

vapply(X, FUN = length, FUN.VALUE = numeric(1L))

```

Now experiment with changing argument to `FUN` or setting `USE.NAMES = FALSE`.

# More with `vapply`

Here we have a fake employee list. We don't have a last name for employee 5.

```{r employees-list}

employees <- list(
  c("first", "last"),
  c("first", "last"),
  c("first", "last"),
  c("first", "last"),
  c("first")
)

employees

```

Can we get employees' first name or concatenate `first` & `last`...again, remember that *everything* is a function call. Thus supplying `[` to `FUN` works. The `1` indicates the elment number we wish to index.

```{r employees-demo}

vapply(employees, FUN = `[`, FUN.VALUE = character(1L), 1)
vapply(employees, FUN = paste0, FUN.VALUE = character(1L), collapse = " ")

```

Let's display our numeric list again.

```{r X-display}

# display list `X` again for convenience
X

```

...what if we wanted some descriptive stats for each item in `X`

- how might you handle `NAs`?
- how might you change output's orientation (i.e., stat names as columns)?

```{r vapply-matrix_out1} 

vapply(X, FUN = function(x) {
  c(Min = min(x), Max = max(x), Mean = mean(x))
}, FUN.VALUE = numeric(3L))

```

same idea, but now we've included `N` or count

```{r vapply-matrix_out2}

vapply(X, FUN = function(x) {
  c(N = length(x), Min = min(x), Max = max(x), Mean = mean(x))
}, FUN.VALUE = numeric(4L))

```

probably the preferred orientation

```{r vapply-matrix_out3} 

t(vapply(X, FUN = function(x) {
  c(N = length(x), Min = min(x), Max = max(x), Mean = mean(x))
}, FUN.VALUE = numeric(4L)))

```

```{r vapply-list_out, eval=FALSE, echo=FALSE}

t(vapply(X, FUN = function(x) {
  list(N = length(x), Min = min(x), Max = max(x), Mean = mean(x))
}, FUN.VALUE = list(N = NA, Min = NA, Max = NA, Mean = NA)))

```

# List of Functions

We could pass a list of functions as an argument to `vapply`'s `X`. Though this convention is not as common. *Note*: the last function in the list is a custom function that returns count of values less than 5. `x < 5` returns a Boolean, and summing a Boolean returns number `TRUE`, as `TRUE` = 1, `FALSE` = 0.

```{r list-functions}

funs <- list(
  Mean = mean,
  Sd = sd,
  N = length,
  NumValsLT5 = function(x) sum(x < 5)
)

vapply(funs, FUN = function(f, nums) {
  f(nums)
}, FUN.VALUE = numeric(1L), nums = 1:10)

```

# Download Data

Here we use zooplankton data from CDFW's ftp site.

** note the use of package `readxl` ** (install prior to running below)

```{r data-download}

# tempdir()
# list.files(tempdir())

tf <- tempfile(pattern = "thisone", fileext = ".xlsx")

download.file(
  url = "ftp://ftp.wildlife.ca.gov/IEP_Zooplankton/1972-2018MysidMatrix.xlsx",
  # destfile = tempfile(fileext = ".xlsx")
  destfile = tf,
  mode = "ab"
)

# note the space after 2018 in the sheet name --- needed because that space
# exists in the .xlsx file
Zoop <- readxl::read_excel(
  path = tf,
  sheet = "Mysid CPUE Matrix 1972-2018 "
)

# always a good idea to remove (delete) the file after downloading data
unlink(tf)

```

# Check Data

is our data clean

```{r na-check}

vapply(Zoop, FUN = function(x) {
  sum(is.na(x))
}, FUN.VALUE = numeric(1L))

t(noquote(vapply(Zoop, FUN = function(x) {
  c(NumNA = sum(is.na(x)), TypeOf = typeof(x))
}, FUN.VALUE = character(2L))))

```

# Custom Data Summary

(long output)

```{r summary-plus}

lapply(Zoop, FUN = function(x) {
  if (is.double(x)) return(range(x, na.rm = TRUE))
  table(x, useNA = "ifany", dnn = NULL)
})

```

where are the quoted NAs

```{r na-quoted}

vapply(Zoop, FUN = function(x) {
  sum(x %in% "NA")
}, FUN.VALUE = numeric(1L))

```

# Clean Data

```{r char-nas}

char_nas <- vapply(Zoop, FUN = function(x) {
  sum(x %in% "NA")
}, FUN.VALUE = numeric(1L), USE.NAMES = FALSE)

b <- char_nas > 0

head(Zoop[b])

Zoop[b] <- lapply(Zoop[b], FUN = function(x) {
  x[x %in% "NA"] <- NA
  x
})

```

now recheck

```{r na-quoted-recheck}

vapply(Zoop, FUN = function(x) {
  sum(x %in% "NA")
}, FUN.VALUE = numeric(1L))

```

# Scale Data

```{r scaled}

cols <- c("N_ mercedis", "A_ hwanhaiensis")

fv <- nrow(Zoop)

apply(Zoop[cols], MARGIN = 2, FUN = range)

zoop_scaled <- vapply(Zoop[cols], FUN = function(x) {
  x / (max(x) - min(x))
}, FUN.VALUE = numeric(fv))

apply(zoop_scaled, MARGIN = 2, FUN = range)


```

```{r plot-not-scaled}

plot(x = Zoop[["Year"]], y = Zoop[[cols[1]]])
points(x = Zoop[["Year"]], y = Zoop[[cols[2]]], col = "red")

```

```{r plot-scaled}

plot(x = Zoop[["Year"]], y = zoop_scaled[, "N_ mercedis"])
points(x = Zoop[["Year"]], y = zoop_scaled[, "A_ hwanhaiensis"], col = "red")

```

```{r mean-temp-yr1}

mean_temp_yr <- with(data = Zoop, expr = {
  
  s <- split(Temperature, f = Year)
  
  vapply(s, FUN = mean, FUN.VALUE = numeric(1L))
  
})

mean_temp_yr

```

```{r mean-temp-yr2}

mean_temp_yr <- with(data = Zoop, expr = {
  
  s <- split(Temperature, f = Year)
  
  vapply(s, FUN = mean, FUN.VALUE = numeric(1L), na.rm = TRUE)
  
})

mean_temp_yr

```

```{r mean-temp-yr3}

mean_temp_yr <- with(data = Zoop, expr = {
  
  s <- split(Temperature, f = Year)
  
  # t(vapply(s, FUN = function(x, ...) {
  #   c(Mean = mean(x, ...), Sd = sd(x, ...))
  # }, FUN.VALUE = numeric(2L), na.rm = TRUE))
  
  t(vapply(s, FUN = function(x) {
    nna <- sum(is.na(x))
    x <- Filter(f = Negate(is.na), x = x)
    c(N = length(x), NNA = nna, Mean = mean(x), Var = var(x))
  }, FUN.VALUE = numeric(4L)))
  
})

str(mean_temp_yr)
tail(mean_temp_yr)

```

```{r mean-temp-yr-mon1}

mean_temp_yr_mon <- with(data = Zoop, expr = {
  
  # extract month from Date (as "01", "02", "03", etc.)
  m <- format(SampleDate, format = "%m")
  
  s <- split(Temperature, f = list(Year, m), drop = FALSE) #, sep = "_"
  
  # t(vapply(s, FUN = function(x, ...) {
  #   c(Mean = mean(x, ...), Sd = sd(x, ...))
  # }, FUN.VALUE = numeric(2L), na.rm = TRUE))
  
  t(vapply(s, FUN = function(x) {
    nna <- sum(is.na(x))
    x <- Filter(f = Negate(is.na), x = x)
    c(N = length(x), NNA = nna, Mean = mean(x), Var = var(x))
  }, FUN.VALUE = numeric(4L)))
  
})

dim(mean_temp_yr_mon)
dimnames(mean_temp_yr_mon)[[2]]
head(dimnames(mean_temp_yr_mon)[[1]], n = 10)

```

```{r mean-temp-yr-mon-show}

head(mean_temp_yr_mon)

```

```{r mean-temp-yr-mon2}

mean_temp_yr_mon <- with(data = Zoop, expr = {
  
  # extract month from Date (as "01", "02", "03", etc.)
  m <- as.numeric(format(SampleDate, format = "%m"))
  
  out <- aggregate(
    Temperature,
    by = list(Year = Year, Mon = m),
    FUN = function(x) {
      nna <- sum(is.na(x))
      x <- Filter(f = Negate(is.na), x = x)
      c(N = length(x), NNA = nna, Mean = mean(x), Var = var(x))
    }
  )
  
  out
})

str(mean_temp_yr_mon)

```

```{r mean-temp-yr-mon3}

mean_temp_yr_mon <- with(data = Zoop, expr = {
  
  # extract month from Date (as "01", "02", "03", etc.)
  m <- as.numeric(format(SampleDate, format = "%m"))
  
  out <- aggregate(
    Temperature,
    by = list(Year = Year, Mon = m),
    FUN = function(x) {
      nna <- sum(is.na(x))
      x <- Filter(f = Negate(is.na), x = x)
      c(N = length(x), NNA = nna, Mean = mean(x), Var = var(x))
    }
  )
  
  data.frame(
    out[c("Year", "Mon")],
    out[["x"]]
  )
})

str(mean_temp_yr_mon)

```

```{r plot-mult-y1}

b <- grepl(pattern = "^[A-Z]\\_", x = colnames(Zoop))
nms <- colnames(Zoop)[b]
nms

vapply(nms, FUN = function(y, d, xVar) {
  
  plot(x = d[[xVar]], y = d[[y]], xlab = xVar, ylab = y)
  
  mean(d[[y]], na.rm = TRUE)
  
}, FUN.VALUE = numeric(1L), d = Zoop, xVar = "Year")

```

```{r plot-mult-y2}

par(mfrow = c(4, 2))

vapply(nms, FUN = function(y, d, xVar) {
  
  plot(x = d[[xVar]], y = d[[y]], xlab = xVar, ylab = y)
  
  mean(d[[y]], na.rm = TRUE)
  
}, FUN.VALUE = numeric(1L), d = Zoop, xVar = "Secchi")

```

