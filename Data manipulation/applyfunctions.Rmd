---
title: "Iteration"
author: "Rosemary Hartman"
date: "12/6/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```


#	Loops

We've now got our zooplankton data set in a format we can work with, but now we probably want to do some calculations on it. What if we want to calculate annual average catch?

We can do it one year at a time:
```{r}

mean(filter(CBlong, Year == 1984)$CPUE)

mean(filter(CBlong, Year == 1985)$CPUE)

mean(filter(CBlong, Year == 1986)$CPUE)

```
But we don't want to keep copying and pasting! Instead, we can use a loop:


```{r}

#first we set up an empty data frame to accept our output
output = data.frame(year = min(CBlong$Year):max(CBlong$Year), Mean = NA)


for (i in 1:nrow(output)) {   # sequence
  
  output$Mean[i] = mean(filter(CBlong, Year == output$year[i])$CPUE, na.rm = T)  #body
}

```

That took a few seconds. You may have heard "don't use for loops in R - they are slow!" That is true when you are dealing with very large data sets, but remember: If it works, it's good code! However, you might want to try some different approaches to speed up your data processing, or make your code more readable.


# Apply

```{r}
#Insert Jason's code here
```


# Split-apply-combine

The package dplyr has some nifty tools to group data sets based on values and apply functions to the groups. In this case, we want to group our data frame based on year and apply the "mean" fuction to CPUE. One nice thing about this is you don't have to set up an empty data frame to save your work.

```{r}

CBmeans = summarize(group_by(CBlong, Year), #group it by Year
                    MeanCPUE = mean(CPUE)) #Calculate Mean CPUE
#much faster!


```
# Now it's your turn

1. What is the average CPUE of each species?

2. What is the maximum CPUE of Eurytemora in Suisun Bay by year?

3. Calculate the relative % composition of each species by year (this is a hard one).
