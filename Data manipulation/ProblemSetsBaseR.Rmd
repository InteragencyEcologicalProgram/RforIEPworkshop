---

---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

knitr::opts_knit$set(root.dir = "~/RProjects/RforIEPworkshop/Data manipulation")

```

# Load Data

```{r load-data}

CBdata <- read.csv(
  file = "CBdata.csv",
  header = TRUE,
  stringsAsFactors = FALSE
)

```

# Check Data

```{r check-data}

# check row and column count
dim(CBdata)

# long output, but a good option
# str(CBdata)
# summary(CBdata)

```

#### Check `NA`

Here, we write a custom function `CountNA` to help us count `NA`s and character NAs. We pass the function to `FUN` in `vapply` - see next step.

*Note*: for now `sum(x %in% c("NA", "na"))` will suffice to check for character NAs. Likely, there are more robust ways, perhaps even using `base::grepl` or the like.

```{r count-na-function}

CountNA <- function(x) {
  char_na <- sum(x %in% c("NA", "na"))
  c(CharNA = char_na, `NA` = sum(is.na(x)))
}

```

The output is long, but we see seven fields have count `NA` > 0. Good to know.

```{r check-na}

t(vapply(CBdata, FUN = CountNA, FUN.VALUE = numeric(2L)))

```

You'll want to develop other data-checking and (or) data-cleaning procedures as needed. For now , we'll suffice at checking `NA`s.

# Questions (from `applyfunctions.Rmd`)

#### What is the average CPUE of each species?

The first step to answering this question is which field or fields contain CPUE (catch-per-unit-effort)?

A call to `base::colnames` reveals each species is a field. Are data are in "wide" format. We also see species field names are all CAPS. This can play to our adavantage, as R is case sensitive.

*Note*: we assume data in each species field are CPUE.

```{r column-names}

colnames(CBdata)

```

A call to `base::grepl` using `pattern = "[A-Z]$"` (i.e., checking for capital letters from the text end) yields `TRUE` for all species field names.

```{r species-columns}

# `b` for Boolean
b <- grepl(pattern = "[A-Z]$", x = colnames(CBdata))

sum(b)

# just for easier observartion (run as desired)
# cbind(colnames(CBdata), b)
# or...
# View(cbind(colnames(CBdata), b), title = "SpeciesFieldCheck")

```

Verify for yourself there are in fact `r sum(b)` species. Now to answer our question...simply call `base::colMeans` on the subsetted `CBdata`. Play with display format as desired (e.g., call `as.data.frame` on the `colMeans` output).

```{r mean-cpue}

colMeans(CBdata[b])

# for variable clean up
rm(b)

```

#### What is the maximum CPUE of Eurytemora in Suisun Bay by year?

Here we get a bit specific. We seek annual maximum CPUE for only Eurytemora in Suisun Bay. Our "filter" is Suisun Bay, and our "split" is by year. *Note*: for this purpose, we assume `EURYTEM` is the desired field.

```{r eurytem-year-split}

eurytem_year <- split(CBdata[c("Region", "EURYTEM")], f = CBdata["Year"])

```

Because, variable `eurytem_year` is a list, we can use `vapply` to loop through each year. Each element in `eurytem_year` is a data.frame with two fields: `Region` & `EURYTEM`. Our anonymous function has one parameter: `d` (short for data).

- `b <- d[["Region"]] %in% "SuiBay"` is our "filter" selecting only `SuiBay` (we assume Suisun Bay)
- `max(d[b, "EURYTEM"])` returns the maximum value --- a single numeric --- on the subsetted data (just to be safe you could include `, na.rm = TRUE` but we know from our clean data check no `NA`s exist in our species fields)

Output below can be assigned to a variable, and then plotted if desired.

```{r eurytem-year-max}

vapply(eurytem_year, FUN = function(d) {
  b <- d[["Region"]] %in% "SuiBay"
  max(d[b, "EURYTEM"])
}, FUN.VALUE = numeric(1L))

```




3. Calculate the relative % composition of each species by year (this is a hard one).
