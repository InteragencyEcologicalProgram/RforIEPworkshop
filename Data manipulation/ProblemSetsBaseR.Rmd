---
output: github_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

knitr::opts_knit$set(root.dir = "~/RProjects/RforIEPworkshop/Data manipulation")

```

# Load Data

Read the `.csv` file into your current R session. *Note*: your file path to `file` may differ.

```{r load-data}

CBdata <- read.csv(
  file = "CBdata.csv",
  header = TRUE,
  stringsAsFactors = FALSE
)

```

# Check Data

Check your data with calls to built-in R functions. `dim` returns number of rows and number of columns. We have many columns (n=`r ncol(CBdata)`).

```{r check-data}

# check row and column count
dim(CBdata)

# long output, but a good option
# str(CBdata)
# summary(CBdata)

```

#### Check `NA`

Here, we write a custom function `CountNA` to help us count `NA`s and character NAs. We pass the function to `FUN` in `vapply` - see next step.

*Note*: for now `sum(x %in% c("NA", "na"))` will suffice to check for character NAs. Likely, there are more robust ways, perhaps even using `base::grepl` or the like.

```{r count-na-function}

CountNA <- function(x) {
  char_na <- sum(x %in% c("NA", "na"))
  c(CharNA = char_na, `NA` = sum(is.na(x)))
}

```

The output is long, but we see seven fields have count `NA` > 0. Good to know.

```{r check-na}

t(vapply(CBdata, FUN = CountNA, FUN.VALUE = numeric(2L)))

```

You'll want to develop other data-checking and (or) data-cleaning procedures as needed. For now , we'll suffice at checking `NA`s.

# Questions (from `applyfunctions.Rmd`)

#### What is the average CPUE of each species?

The first step to answering this question is which field or fields contain CPUE (catch-per-unit-effort)?

A call to `base::colnames` reveals each species is a field. Are data are in "wide" format. We also see species field names are all CAPS. This can play to our advantage, as R is case sensitive.

*Note*: we assume data in each species field are CPUE.

```{r column-names}

colnames(CBdata)

```

A call to `base::grepl` using `pattern = "[A-Z]$"` (i.e., checking for capital letters from the text end) yields `TRUE` for all species field names.

```{r species-columns}

# `b` for Boolean
b <- grepl(pattern = "[A-Z]$", x = colnames(CBdata))

sum(b)

# just for easier observartion (run as desired)
# cbind(colnames(CBdata), b)
# or...
# View(cbind(colnames(CBdata), b), title = "SpeciesFieldCheck")

```

Verify for yourself there are in fact `r sum(b)` species. Now to answer our question...simply call `base::colMeans` on the subsetted `CBdata`. Play with display format as desired (e.g., call `as.data.frame` on the `colMeans` output).

```{r mean-cpue}

colMeans(CBdata[b])

```

#### What is the maximum CPUE of Eurytemora in Suisun Bay by year?

Here we get a bit specific. We seek annual maximum CPUE for only Eurytemora in Suisun Bay. Our "filter" is Suisun Bay, and our "split" is by year. *Note*: for this purpose, we assume `EURYTEM` is the desired field.

```{r eurytem-year-split}

eurytem_year <- split(CBdata[c("Region", "EURYTEM")], f = CBdata["Year"])

```

Because, variable `eurytem_year` is a list, we can use `vapply` to loop through each year. Each element in `eurytem_year` is a data.frame with two fields: `Region` & `EURYTEM`. Our anonymous function has one parameter: `d` (short for data).

- `b <- d[["Region"]] %in% "SuiBay"` is our "filter" selecting only `SuiBay` (we assume Suisun Bay)
- `max(d[b, "EURYTEM"])` returns the maximum value --- a single numeric --- on the subsetted data (just to be safe you could include `, na.rm = TRUE` but we know from our clean data check no `NA`s exist in our species fields)

Output below can be assigned to a variable, and then plotted if desired.

```{r eurytem-year-max}

vapply(eurytem_year, FUN = function(d) {
  b <- d[["Region"]] %in% "SuiBay"
  max(d[b, "EURYTEM"])
}, FUN.VALUE = numeric(1L))

```

#### Calculate the relative % composition of each species by year (this is a hard one).

We assume we are to use CPUE values (i.e., in our wide format, each species column).

**Step 1**: `split` all species data by year. Recall our variable `b`, which gave `TRUE` for field names with all caps (i.e., species names).

```{r species-year}

species_year <- split(CBdata[b], f = CBdata[["Year"]])

```

Now each element in list `species_year` represents a year. Run `str(species_year[["2018"]])` as an example to verify this element is a dataframe with `r sum(b)` variables. Try other years, too, if you wish.

**Step 2**: Each row in the data.frame (either `CBdata` or `species_year`) represents a sampling event (i.e, date-station-tow). If we sum each species (i.e., each column), we get the yearly total. So here we need a call to `base::colSums`. Below works, but we need "relative % composition".

```{r col-sums-demo}

species_year_total <- t(
  vapply(species_year, FUN = colSums, FUN.VALUE = numeric(sum(b)))
)

```

**Step 3**: A call to `base::prop.table` should do the trick. `margin = 1` indicates by rows (i.e., by year). *Note*: If not using a call to `t` like above, then set `margin = 2` for columns.

```{r rel-percent-comp}

rel_percent_comp <- prop.table(species_year_total, margin = 1)

# double-check rows should sum to 1
# rowSums(rel_percent_comp)

# for ease of viewing rather than in the console
# View(rel_percent_comp)

```

---
run: `r format(Sys.time(), format = "%B %d %Y @ %H%M")`  
&copy; IEP educational series
