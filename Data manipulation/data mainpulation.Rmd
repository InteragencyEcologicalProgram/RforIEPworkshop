---
title: "IEP Data Manipulation and Processing"
author: "Rosemary Hartman"
date: "12/2/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Outline

1. Importing data
1. Foundational skills of data manipulations
2. Detecting errors and outliers
3. Dataset restructuring
4. Missing data
5. Miscellaneous data manipulation
6. getting data out of R


Do we want to go into data organization at all? Maybe introduce "[tidy data](https://learning.nceas.ucsb.edu/2019-11-RRCourse/data-modeling-tidy-data.html)"?


## Importing data

There are multiple different ways of getting your data into R. RStudio 
has a nice little point=and-click interface that lets you import your dataset, however using
the GUI makes it more difficult to replicate your work later. Therefore, it's better
to use the comand-line to import your data.

We are going to use the Zooplankton Survey data for this demonstration. It's available 
[here](ftp://ftp.wildlife.ca.gov/IEP_Zooplankton/1972-2018CBMatrix.xlsx)

If you have a .csv file, you can use base R. So I went into the excel file and saved
one of the worksheets as a .csv

```{r imports}
?read.csv

CBdata = read.csv("CBdata.csv", stringsAsFactors = F)
head(CBdata)

```

But what if we want to import the origional excel file? For that,
we need the "readxl" package

```{r excel}

library(readxl)

?read_excel

#CBdata = read_xlsx("1972-2018CBMatrix.xlsx", sheet = "CB CPUE Matrix 1972-2018")
#Yuck. If you have too many blanks in the begining of your sheet, it thinks it is
#a logical vector. Let's fix that.

CBdata = read_excel("1972-2018CBMatrix.xlsx", 
    sheet = "CB CPUE Matrix 1972-2018", col_types = c("numeric", 
        "numeric", "numeric", "numeric", 
        "date", "text", "text", "text", "numeric", 
        "text", "numeric", "text", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric"))

head(CBdata)

```
## Foundational skills

Do we really want to do data generation? Seems like a lot of work. 
###	Generating data
1.	rnorm, rbinom

### Dealing with data frames

A lot of these skills can be done with either Base R syntax, or "tidyverse"
syntax. Most people find "tidyverse" a little more intuitive, but you
can use whichever you are more comfortable with.

#### Renaming columns

```{r rename}
library(tidyverse)

names(CBdata)

#several options for how to rename your colums

names(CBdata)[names(CBdata)== "SurveyCode"] = "cheese"

names(CBdata)

#you could also just make a new column and delete the old one
CBdata$crackers = CBdata$cheese
CBdata$cheese = NULL

names(CBdata)

#using "rename" is a little more intuitive
CBdata = rename(CBdata, SurveyCode = crackers)

names(CBdata)

```
#### Dropping columns
The zooplankton data set has one row for every sample, and one
column for every species. It also has columns with the sums of groups 
of species (e.g. "All Cladocera"). We want to get rid of those summed
columns because they make the data messy and harder to work with.

```{r}

?select

CBdata2 = select(CBdata, -starts_with("ALL"))
```

####	Reordering columns

But now our "SurveyCode" column is at the end. We want to put it back in the begining.

```{r}
#here's how to do it in base R
CBdata2 = CBdata2[,c(67, 1:66)]

names(CBdata2)

#you can also use the "select" function in dplyr
CBdata2 = select(CBdata2, Survey, Year, SurveyCode, SurveyRep:CRABZOEA)

names(CBdata2)

#I just learned this cool thing when you have a lot of columns!
CBdatatest = select(CBdata2, DAPHNIA, everything())

names(CBdatatest)

```


####	Adding new mutated data

We frequently need to transform data (especially log transformations). We 
might also need to calculate CPUE, or do other stuff, and add our calculated variables
to our data set. 

```{r mutate}

#we can just define a new variable and assign its value with the old variable
CBdata$ln_cals = log(CBdata$ALLCALADULTS + 1)

#or we can use the "mutate" function from dplyr. This is especially
#helpful if you want to make a bunch of variables at once

CBdata = mutate(CBdata, ln_clads = log(ALLCLADOCERA + 1), ln_cyc = log(ALLCYCADULTS +1), ln_all = ln_cals + ln_cyc + ln_clads)

View(CBdata)

```

#### converting among data classes

Even though we read in all our columns based on particular classses, sometimes
we want to change the data class. Sometimes that's super easy, sometimes it's more
difficult. Almost all data classes have an "as" function. as.data.frame, as.character, as.numeric, as.factor, etc. 

Other useful functions:
length(object) # number of elements or components
str(object)    # structure of an object
class(object)  # class or type of an object
names(object)  # names

```{r}


str(CBdata2)

#changing things from characters to factors and back again is really easy
#the "Region" variable would make a good factor

CBdata2$Region = as.factor(CBdata2$Region)

#or we can do it with "mutate" again
CBdata2 = mutate(CBdata2, Station = as.factor(Station)) 

str(CBdata2)

levels(CBdata2$Region)

```
The levels are automatically in alphabetical order. 
If we want to put them in order from west to east we
can change the levels using the "factor" function. Just
put the levels in the order you want. You can also use
this fuction to change the labels of the factors (useful when plotting)

```{r}
?factor

CBdata2$Region = factor(CBdata2$Region, 
                        levels = c("NapaR", "SPBay", 
                                   "CarStrait",  "SuiBay", "SuiMar", "EZ",
                                   "WestDel", "SacR","SJR",
                                   "NEDel","NorDel","SoDel","EastDel"),
                        labels = c("Napa River", "San Pablo Bay",
                                   "Carquinez", "Suisun Bay", "Suisun Marsh",
                                   "EZ", "West Delta", "Sacramento River",
                                   "San Joaquin River", "North East Delta",
                                   "North Delta", "South Delta", "East Delta")
                        )

levels(CBdata2$Region)

```

You can also change from factor to character, factor to numeric,
or numeric to character, or logical values. 

For example, if we wanted to look at crabzoea presence/absence instead
of abundance, we can use "as.logical"

```{r}
CBdata2 = mutate(CBdata2, CRABZOEA_yn = as.logical(CRABZOEA))

View(CBdata2)

CBdata2 = select(CBdata2, -CRABZOEA_yn)

```

# Dataset Restructuring

The data is never in the format you want it. Usually, R likes things to be in "long" format instead of "wide" format. However, data is often published in "wide" format, and community analyses like things in "wide" format, so you need to know how to switch between the two. The functions "pivot_wider" and "pivot_longer" are probably the easiest way to do this.


```{r}
?pivot_longer

CBlong = pivot_longer(CBdata2, #specify the data set you want to pivot
                      cols = ACARTELA:CRABZOEA, #specify the coloms to pivot
                      names_to = "TaxonCode", #give the name of the new column you want to create
                      values_to = "CPUE" #name of the column for the values
                      )

View(CBlong)

```

If we want to put it back in "wide" format, we use "pivot_wider"
```{r}
?pivot_wider

CBwide = pivot_wider(CBlong, #specify the data set you want to pivot
                      id_cols = c(Survey, Year, Date, Station), #Identifier columns (ones you don't want to pivot)
                      names_from = TaxonCode, #give the name of the new column you want to use for the names of the new columns
                      values_from = CPUE #name of the column for the values
                      )

View(CBwide)
```

We can also use this to summarize values as we pivot. For example, if we wanted one row for each year instead of for each sample, we can do that.

```{r}

CBwideY = pivot_wider(CBlong, #specify the data set you want to pivot
                      id_cols = Year, #specify the column with the unique identifier
                      names_from = TaxonCode, #give the name of the new column you want to use for the names of the new columns
                      values_from = CPUE, #name of the column for the values
                      values_fn = list(CPUE = sum) #function to use to combine values
                      )

View(CBwideY)

```

## Merging data
Frequently, we also need to combine several tables. For example, we might want the GPS coordinates for the stations to be included in our zooplankton table. The excel file had those coordinates, but they were in another spread sheet. To put those tables together, we can use the "merge" function.

```{r}

#first let's import the station lookup table from the excel file

taxalookup <- read_excel("1972-2018CBMatrix.xlsx", 
    sheet = "CB Taxa Lookup")
View(taxalookup)

#apparently the first row wasn't the column names! Oh no!

#let's rename that
names(taxalookup) =  c("TaxonCode", "TaxonName", "StartYear", "EndYear")
View(taxalookup)

#get rid of the first and last row
taxalookup = taxalookup[-c(1,58),]
View(taxalookup)

```
Now we can attach the scientific names to the main "CBlong" data frame

```{r}

?merge

CBlong2 = merge(CBlong, taxalookup, by = "TaxonCode")


```

This automatically only keeps rows that are present in both data sets (equivelent to an "inner join" in SQL). If we want to do a left join or a right joing you can set "all.x = T" or "all.y = T".

```{r}
#for example, if we only had scientific names for some of our taxa
taxalookupshort = taxalookup[1:20,]

CBlong3 = merge(CBlong, taxalookupshort, by = "TaxonCode")
nrow(CBlong)
nrow(CBlong3)
#all the rows that weren't in the first 20 taxa have been dropped


CBlong4 = merge(CBlong, taxalookupshort, by = "TaxonCode", all.x = T)
nrow(CBlong4)
View(CBlong4)
#Empty values are now "NA"

```

